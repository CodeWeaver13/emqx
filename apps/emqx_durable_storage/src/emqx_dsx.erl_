%%--------------------------------------------------------------------
%% Copyright (c) 2024-2025 EMQ Technologies Co., Ltd. All Rights Reserved.
%%--------------------------------------------------------------------

-module(emqx_dsx).

-moduledoc """
= EMQX DS eXplorer.

A wrapper that simplifies processing data from the durable storage.
""".

%% API:
-export([create/2, destroy/1, handle_message/3]).

%% internal exports:
-export([]).

-export_type([replay_pos/0, t/1, ack/0, conf/0]).

-include("emqx_ds.hrl").
-include_lib("snabbkaffe/include/trace.hrl").

%%================================================================================
%% Type declarations
%%================================================================================

-record(srs, {
    it :: emqx_ds:iterator(),
    %% Number of messages that should be skipped after position of the
    %% iterator:
    offset = 0 :: non_neg_integer()
}).

-record(ds_sub, {
    stream :: {emqx_ds:slab(), emqx_ds:stream()},
    handle :: emqx_ds:subscription_handle()
}).

-record(s, {
    db,
    tf,
    start_time,
    sub_opts,
    new_streams_watch,
    msg_handler,
    future_streams = [],
    pos,
    ds_subs = #{}
}).

-record(progress, {
    generations = #{} :: #{emqx_ds:shard() => emqx_ds:generation()},
    its = #{} :: #{{emqx_ds:slab(), emqx_ds:stream()} => #srs{} | end_of_stream}
}).

-type progress() :: #progress{}.

-type replay_pos() :: #{{emqx_ds:slab(), emqx_ds:stream()} => emqx_ds:iterator() | end_of_stream}.

-opaque t(Acc) :: #s{
    db :: emqx_ds:db(),
    tf :: emqx_ds:topic_filter(),
    start_time :: emqx_ds:time(),
    sub_opts :: emqx_ds:sub_opts(),
    new_streams_watch :: emqx_ds_new_streams:watch(),
    msg_handler :: payload_handler(Acc),
    pos :: progress(),
    future_streams :: [{emqx_ds:slab(), emqx_ds:stream()}],
    ds_subs :: #{emqx_ds:sub_ref() => #ds_sub{}}
}.

-record(ack, {
    it :: emqx_ds:iterator(),
    subref :: emqx_ds:subscription_handle(),
    seqno :: non_neg_integer()
}).

-opaque ack() :: #ack{}.

-type conf() :: #{
    db := emqx_ds:db(),
    topic_filter := emqx_ds:topic_filter(),
    start_time => emqx_ds:time(),
    progress => progress()
}.

-type payload_handler(Acc) :: %% fun((emqx_ds:slab(), emqx_ds:stream(), offset(), emqx_ds:topic(), emqx_ds:payload(), Acc) ->
                              %%            {ack,
        fun((Acc) -> Acc).

-define(CATCH(EXPR),
    try
        EXPR,
        ok
    catch
        _:_ -> ok
    end
).

%%================================================================================
%% API
%%================================================================================

-spec create(conf(), payload_handler(Acc)) -> t(Acc).
create(#{db := DB, topic_filter := TF} = Cfg, MsgHandler) ->
    {ok, NSW} = emqx_ds_new_streams:watch(DB, TF),
    renew_streams(#s{
        db = DB,
        tf = TF,
        start_time = maps:get(start_time, Cfg, 0),
        sub_opts = maps:get(sub_opts, Cfg, #{max_unacked => 100}),
        new_streams_watch = NSW,
        msg_handler = MsgHandler,
        pos = maps:get(progress, Cfg, #progress{})
    }).

-spec destroy(t(_Acc)) -> ok.
destroy(S = #s{db = DB}) ->
    %% Remvoe new stream watch:
    ?CATCH(emqx_ds_new_streams:unwatch(DB, S#s.new_streams_watch)),
    %% Unsubscribe:
    maps:foreach(
      fun(_SubRef, #ds_sub{handle = Handle}) ->
              ?CATCH(emqx_ds:unsubscribe(DB, Handle))
      end,
      S#s.ds_subs
     ),
    ok.

-spec handle_message(t(Acc), Acc, term()) -> {ok, t(Acc)} | {ok, t(Acc), Acc} | ignore.
handle_message(S = #s{new_streams_watch = NSW}, _Acc, #new_stream_event{subref = NSW}) ->
    {ok, renew_streams(S)};
handle_message(S = #s{ds_subs = DSSubs}, Acc, Reply = #ds_sub_reply{ref = Ref}) ->
    case DSSubs of
        #{Ref := DSSub} ->
            handle_ds_reply(S, Acc, Reply, DSSub);
        #{} ->
            ignore
    end;
handle_message(S = #s{ds_subs = DSSubs}, _Acc, {'DOWN', Ref, process, Pid, Reason}) ->
    %% Handle DS subscription down:
    case DSSubs of
        #{Ref := DSSub = #ds_sub{stream = Stream}} ->
            ?tp(info, emqx_dsx_sub_down, #{
                stream => Stream,
                sub_ref => Ref,
                pid => Pid,
                reason => Reason
            }),
            exit(fixme);
        #{} ->
            ignore
    end;
handle_message(_, _, _) ->
    ignore.

%%================================================================================
%% Internal exports
%%================================================================================

%%================================================================================
%% Internal functions
%%================================================================================

handle_ds_reply(S, _Acc, #ds_sub_reply{ref = _Ref, payload = {ok, end_of_stream}}, _DSSub) ->
    error(fixme);
handle_ds_reply(S, Acc, #ds_sub_reply{ref = _Ref, payload = {ok, _It, Batch}}, _DSSub) ->
    lists:foldl(

      Acc,
      Batch
      )
    {ok, S, Acc}.

renew_streams(S = #s{db = DB, tf = TF, start_time = StartTime}) ->
    {Streams, _Err} = emqx_ds:get_streams(DB, TF, StartTime, #{}),
    schedule_streams(S, Streams).

schedule_streams(
    S = #s{
        db = DB, tf = TF, start_time = StartTime, pos = Pos, ds_subs = DSSubs0, sub_opts = SubOpts
    },
    Streams
) ->
    #progress{generations = Generations0, its = Iterators0} = Pos,
    %% 1. Find minimum generations for shards that haven't been
    %% replayed yet:
    Generations = lists:foldl(
        fun({Shard, Gen}, Acc) ->
            case Generations0 of
                #{Shard := _} ->
                    %% Replay of the shard is already in progress:
                    Acc;
                #{} ->
                    %% This is a new shard. Find the
                    %% minimal known generation:
                    maps:update_with(
                        Shard,
                        fun(A) -> min(A, Gen) end,
                        Gen,
                        Acc
                    )
            end
        end,
        #{},
        Streams
    ),
    %% 2. Find streams that can be replayed now and those that can be
    %% replayed in the future:
    {Iterators, DSSubs, FutureStreams} = lists:foldl(
        fun({{Shard, Gen}, Stream} = Key, {AccIterators, AccDSSubs, AccFuture}) ->
            #{Shard := CurrentGen} = Generations,
            if
                Gen =:= CurrentGen ->
                    %% This stream belongs to the current generation:
                    case AccIterators of
                        #{Key := _} ->
                            %% Already known:
                            {AccIterators, AccDSSubs, AccFuture};
                        #{} ->
                            %% This is a new one:
                            {ok, It} = emqx_ds:make_iterator(DB, Stream, TF, StartTime),
                            {ok, Handle, SubRef} = emqx_ds:subscribe(DB, It, SubOpts),
                            {
                                AccIterators#{Key => #srs{it = It}},
                                AccDSSubs#{SubRef => #ds_sub{stream = Key, handle = Handle}},
                                AccFuture
                            }
                    end;
                Gen < CurrentGen ->
                    %% This stream belongs to a generation that has
                    %% been already fully replayed:
                    {AccIterators, AccDSSubs, AccFuture};
                Gen > CurrentGen ->
                    {AccIterators, AccDSSubs, [Key | AccFuture]}
            end
        end,
        Streams,
        {Iterators0, DSSubs0, []}
    ),
    S#s{
        future_streams = FutureStreams,
        pos = #progress{generations = Generations, its = Iterators},
        ds_subs = DSSubs
    }.
